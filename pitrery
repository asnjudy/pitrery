#!/bin/bash
#
# Copyright 2011-2016 Nicolas Thauvin. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

version="2.0-dev"

# Hard coded configuration
PGXLOG=
BACKUP_DIR="/var/lib/pgsql/backups/pitr"
STORAGE="tar"
BACKUP_HOST=
BACKUP_USER=
BACKUP_COMPRESS_BIN="gzip -4"
BACKUP_COMPRESS_SUFFIX="gz"
BACKUP_UNCOMPRESS_BIN=
PGPSQL="psql"
PRE_BACKUP_COMMAND=
POST_BACKUP_COMMAND=
LOG_TIMESTAMP="no"
USE_ISO8601_TIMESTAMPS="no"


config_dir="/etc/pitrery"
config="pitr2.conf"



out_rc=0

usage() {
    case $1 in
        list)
            echo "`basename $0` list - Display information about backups"
            echo
            echo "usage: `basename $0` list [options] [[user@]host:]/path/to/backups"
            echo
            echo "options:"
            echo "    -v              Display details of the backup"
            echo
            echo "    -?              Print help"
            echo
            exit ${2:-0}
            ;;
        backup)
            echo "`basename $0` backup - Perform a base backup"
            echo
            echo "usage: `basename $0` backup [options] [[[user@]host:]/path/to/backups]"
            echo
            echo "options:"
            echo "    -D dir               Path to \$PGDATA"
            echo "    -s mode              Storage method, tar or rsync"
            echo "    -c compress_bin      Compression command for tar method"
            echo "    -e compress_suffix   Suffix added by the compression program"
            echo "    -t                   Use ISO 8601 format to name backups"
            echo "    -T                   Timestamp log messages"
            echo
            echo "    -P PSQL              path to the psql command"
            echo "    -h HOSTNAME          database server host or socket directory"
            echo "    -p PORT              database server port number"
            echo "    -U NAME              connect as specified database user"
            echo "    -d DATABASE          database to use for connection"
            echo
            echo "    -?                   Print help"
            echo
            exit ${2:-0}
            ;;
        restore)
            echo "`basename $0` restore - Restore a base backup and prepare PITR"
            echo
            echo "usage: `basename $0` restore [options] [[user@]host:]/path/to/backups"
            echo
            echo" options:"
            echo "    -D dir               Path to target \$PGDATA"
            echo "    -x dir               Path to the xlog directory (only if outside \$PGDATA)"
            echo "    -d date              Restore until this date"
            echo "    -O user              If run by root, owner of the files"
            echo "    -t tblspc:dir        Change the target directory of tablespace \"tblspc\""
            echo "                           this switch can be used many times"
            echo "    -n                   Dry run: show restore information only"
            echo "    -R                   Overwrite destination directories"
            echo "    -c compress_bin      Uncompression command for tar method"
            echo "    -e compress_suffix   Suffix added by the compression program"
            echo "    -r command           Command line to use in restore_command"
            echo "    -C config            Configuration file for restore_xlog in restore_command"
            echo "    -T                   Timestamp log messages"
            echo
            echo "    -?                   Print help"
            echo
            exit ${2:-0}
            ;;
        purge)
            echo "`basename $0` purge - Clean old base backups and archived WAL files"
            echo
            echo "usage: `basename $0` purge [options] [[user@]host:]/path/to/backups"
            echo
            echo "options:"
            echo "    -m count     Keep this number of backups"
            echo "    -d days      Purge backups older than this number of days"
            echo "    -N           Dry run: show what would be purged only"
            echo
            echo "    -T           Timestamp log messages"
            echo "    -?           Print help"
            echo
            exit ${2:-0}
            ;;
        check)
            echo "`basename $0` check - Verify configuration and backups integrity"
            echo
            echo "usage: `basename $0` check [options] [config_file]"
            echo
            echo "options:"
            echo "    -C conf              Configuration file"
            echo
            echo "    -?                   Print help"
            echo
            exit ${2:-0}
            ;;
        configure)
            echo "`basename $0` configure - Create a configuration file from the command line"
            echo
            echo "usage: `basename $0` configure [options] [[user@]host:]/path/to/backups"
            echo
            echo "options:"
            echo "    -o config_file         Output configuration file"
            echo "    -f                     Overwrite the destination file"
            echo "    -C                     Do not connect to PostgreSQL"
            echo
            echo "    -l label               Backup label"
            echo "    -s mode                Storage method, tar or rsync"
            echo "    -m count               Number of backups to keep"
            echo "    -g days                Remove backup older then this number of days"
            echo "    -D dir                 Path to \$PGDATA"
            echo "    -a [[user@]host:]/dir  Place to store WAL archives"
            echo
            echo "    -P psql                Path to the psql command"
            echo "    -h hostname            Database server host or socket directory"
            echo "    -p port                Database server port number"
            echo "    -U name                Connect as specified database user"
            echo "    -d database            Database to use for connection"
            echo
            echo "    -?                     Print help"
            echo
            exit ${2:-0}
            ;;
        help)
            echo "`basename $0` help - Print help, optionnally for an action"
            echo
            echo "usage: `basename $0` help [options] [action]"
            echo
            echo "options:"
            echo "    -?                     Print help"
            echo
            exit ${2:-0}
            ;;
    esac

    # Fallback to the main command usage
    echo "`basename $0` $version - PostgreSQL Point In Time Recovery made easy"
    echo
    echo "usage: `basename $0` [options] action [args]"
    echo
    echo "options:"
    echo "    -c file      Path to the configuration file"
    echo "    -l           List configuration files in the default directory"
    echo "    -V           Display the version and exit"
    echo "    -?           Print help"
    echo
    echo "actions:"
    echo "    list - Display information about backups"
    echo "    backup - Perform a base backup"
    echo "    restore - Restore a base backup and prepare PITR"
    echo "    purge - Clean old base backups and archived WAL files"
    echo "    check - Verify configuration and backups integrity"
    echo "    configure - Create a configuration file from the command line"
    echo "    help - Print help, optionnally for an action"
    echo
    exit ${2:-0}
}

# Apply an extra level of shell quoting to each of the arguments passed.
# This is necessary for remote-side arguments of ssh (including commands that
# are executed by the remote shell and remote paths for scp and rsync via ssh)
# since they will strip an extra level of quoting off on the remote side.
# This makes it safe for them to include spaces or other special characters
# which should not be interpreted or cause word-splitting on the remote side.
qw() {
    while (( $# > 1 )); do
	printf "%q " "$1"
	shift
    done
    (( $# == 1 )) && printf "%q" "$1"
}

can_cleanup="no"
cleanup() {
    # Ensure we have a safe guard against removing data too soon
    [ "$can_cleanup" = "yes" ] || return 0

    # Cleanup depends on the action and the location of the backups
    case $action in
        "backup")
            info "cleaning..."
            if [ "$backup_local" = "yes" ]; then
	        if [ -d "$backup_dir" ]; then
	            rm -rf -- "$backup_dir"
	        fi
            elif [ -n "$backup_ssh_target" ] && [ -n "$backup_dir" ]; then
	        bd=$(qw "$backup_dir")
	        ssh -n -- "$backup_ssh_target" "test -d $bd && rm -rf -- $bd" 2>/dev/null
            fi
            
            [ -n "$tblspc_list" ] && rm -f -- "$tblspc_list"
            [ -n "$replslot_list" ] && rm -f -- "$replslot_list"
            [ -n "$psql_stderr" ] && rm -f -- "$psql_stderr"
            [ -n "$backup_label_file" ] && rm -f -- "$backup_label_file"
            [ -n "$tablespace_map_file"  ] && rm -f -- "$tablespace_map_file"
            ;;
    esac
}

# Messaging functions
now() {
    [ "$LOG_TIMESTAMP" = "yes" ] && echo "$(date "+%F %T %Z ")"
}

die() {
    echo "$(now)FATAL: $*" 1>&2
    cleanup
    exit 1
}

error() {
    echo "$(now)ERROR: $*" 1>&2
    out_rc=1
}

warn() {
    echo "$(now)WARNING: $*" 1>&2
}

info() {
    echo "$(now)INFO: $*"
}


load_config() {
    # Load the configuration file
    if [ -f "$config" ]; then
	. "$config"
    else
        # Output an error if the file is missing and the user
        # specified it on the command line
        if [ "$cli_config" = "yes" ]; then
	    error "cannot access configuration file: $config"
        fi
    fi
}

parse_target_uri() {
    local backup_target=$1
    local archive_target=$2

    if [ -n "$backup_target" ]; then
        # Parse the backuptarget into user, host and path
        backup_user="$(echo $backup_target | grep '@' | cut -d'@' -f1 )"
        backup_host="$(echo $backup_target | grep ':' | sed -re 's/(.*):(.*)/\1/' | cut -d'@' -f2 )"
        backup_dir="$(echo $backup_target | sed -re 's/(.*):(.*)/\2/')"
       
    else
        # Fallback to the values from the configuration file
        [ -n "$BACKUP_USER" ] && backup_user=$BACKUP_USER
        [ -n "$BACKUP_HOST" ] && backup_host=$BACKUP_HOST
        [ -n "$BACKUP_DIR" ] && backup_dir=$BACKUP_DIR
    fi

    [ -n "$backup_dir" ] || error "missing backup directory"
    
    # Deduce if backup is local
    if [ -z "$backup_host" ]; then
        backup_local="yes"
    else
        backup_local="no"

        # Wrap IPv6 addresses with brackets
        echo $backup_host | grep -qi '^[0123456789abcdef:]*:[0123456789abcdef:]*$' && backup_host="[${backup_host}]"

        # Add a shortcut for ssh/rsync commands
        backup_ssh_target=${backup_user:+$backup_user@}$backup_host
    fi
    
    # Parse archive target the same way
    if [ -n "$archive_target" ]; then
        archive_user="$(echo $archive_target | grep '@' | cut -d'@' -f1 )"
        archive_host="$(echo $archive_target | grep ':' | sed -re 's/(.*):(.*)/\1/' | cut -d'@' -f2 )"
        archive_dir="$(echo $archive_target | sed -re 's/(.*):(.*)/\2/')"
    else
        # Fallback to the values of the configuration file. When the
        # path is not provided in the config file, fallback to backup values
        if [ -n "$ARCHIVE_DIR" ]; then
            [ -n "$ARCHIVE_USER" ] && archive_user=$ARCHIVE_USER
            [ -n "$ARCHIVE_HOST" ] && archive_host=$ARCHIVE_HOST
            archive_dir=$ARCHIVE_DIR
        else
            archive_user="$backup_user"
            archive_host="$backup_host"
            archive_dir="$backup_dir/archived_xlog"
        fi
    fi

    # Deduce if archives are local
    if [ -z "$archive_host" ]; then
	archive_local="yes"
    else
	archive_local="no"

        # Wrap IPv6 addresses with brackets
        echo $archive_host | grep -qi '^[0123456789abcdef:]*:[0123456789abcdef:]*$' && archive_host="[${archive_host}]"

        # Add a shortcut for ssh/rsync commands
        archive_ssh_target=${archive_user:+$archive_user@}$archive_host
    fi

    [ -n "$archive_dir" ] || error "missing archive directory"

}

# Backup related functions
post_backup_hook() {
    if [ -n "$POST_BACKUP_COMMAND" ]; then
	# We need to set PITRERY_BACKUP_DIR again here, because it will have
	# changed since the PRE_BACKUP_COMMAND was run, unless something failed
	# and we're bailing out early via error_and_hook().
	info "running post backup command"
	PITRERY_HOOK="post_backup"
	PITRERY_BACKUP_DIR=$backup_dir
	export PITRERY_EXIT_CODE
	if ! $POST_BACKUP_COMMAND; then
	    die "post_backup command exited with a non-zero code"
	fi
    fi
}

# This special error function permit to run the post hook when the
# backup fails. This is because the post hook must run after the pre
# hook, while it is possible to have failure before (which need
# error())
die_and_hook() {
    echo "$(now)FATAL: $*" 1>&2
    PITRERY_EXIT_CODE=1
    post_backup_hook
    cleanup
    exit 1
}

stop_backup() {
    # This function is a signal handler, so block signals it handles
    trap '' INT TERM EXIT

    # Tell PostgreSQL the backup is done
    info "stopping the backup process"
    if (( $pg_version >= 90600 )) && (( ${BASH_VERSINFO[0]} >= 4 )); then

        # We have to parse the multiple column output of
        # pg_stop_backup(), so change the field separator to , so that
        # the pipe does not conflict with the output from
        # get_psql_output, which uses pipes for newline (newlines get
        # lost when storing the output as a string)
        echo '\pset fieldsep ,' >&${COPROC[1]}
        get_psql_output > /dev/null

        echo "select labelfile, spcmapfile from pg_stop_backup(false);" >&${COPROC[1]}
        if [ $? != 0 ]; then
            check_psql_stderr || cat $psql_stderr
            die_and_hook "could not stop backup process"
        fi

        result=$(get_psql_output)
        if [ -z "$result" ]; then
            check_psql_stderr || cat $psql_stderr
            die_and_hook "error while stopping the backup process"
        fi

        echo '\pset fieldsep |' >&${COPROC[1]}
        get_psql_output > /dev/null

        # We need a stop time for the backup to make the automatic
        # time-based selection of the backup. The stop time is not
        # part of the output of pg_stop_backup().
        echo "select to_char(now(), 'IYYY-MM-DD HH24:MI:SS TZ');" >&${COPROC[1]}
        if [ $? != 0 ]; then
            check_psql_stderr || cat $psql_stderr
            die_and_hook "could not get the stop time of the backup"
        fi

        stop_time=$(get_psql_output)
        if [ -z "$stop_time" ]; then
            check_psql_stderr || cat $psql_stderr
            die_and_hook "could not get the stop time of the backup"
        fi

        # Get the backup_label. We keep the contents in memory, so
        # that thes signal handler does not create any temporary files
        label_contents=$(cut -d',' -f1 <<< "$result")

        # Add the stop time field usually found in the archived label
        # file from exclusive backups
        label_contents="${label_contents}STOP TIME: $stop_time"

        # Get the tablespace map file
        spcmap_contents=$(cut -d',' -f2- <<< "$result")


    else
        if ! "${psql_command[@]}" -Atc "SELECT pg_stop_backup();" -- "$psql_condb" >/dev/null; then
	    die_and_hook "could not stop backup process"
        fi
    fi

    # Reset the signal handler, this function should only be called once
    trap - INT TERM KILL EXIT
}



while getopts "c:lV?" opt; do
    case $opt in
	c)
            config=$OPTARG
            cli_config="yes"
            ;;
	l) # List the configuration files and exit
            info "listing configuration files in $config_dir"
            for x in "$config_dir"/*.conf; do
	        basename -- "$x" .conf
            done
            exit 0
            ;;
	V) echo "pitrery $version"; exit 0;;
	'?') usage;;
	*) die "error while processing options";;
    esac
done

# Ensure failed globs will be empty, not left containing the literal glob pattern
shopt -s nullglob

# check for an action/subcommand, ensure OPTIND is correctly set to
# process the options of the action
if (( $# < 1 )); then
    error "missing action"
    usage 1
fi

action=${@:$OPTIND:1}
OPTIND=$(( $OPTIND + 1 ))

# Process the help action as soon as possible, it boils down to
# printing usage and exiting
if [ "$action" = "help" ]; then
    while getopts "?" arg  2>/dev/null; do
	case $arg in
            '?') usage "help";;
            *) die "error while processing options";;
        esac
    done

    usage ${@:$OPTIND:1}
fi

# Check if the config option is a path or just a name in the
# configuration directory.  Prepend the configuration directory and
# .conf when needed.
if [[ $config != */* ]]; then
    config="$config_dir/$(basename -- "$config" .conf).conf"
fi


opts=()
case $action in
    list)
	load_config

	# Parse args after action: they should take precedence over the configuration
	while getopts "v?" arg 2>/dev/null; do
	    case $arg in
		v) verbose="yes";;
		'?') usage "list";;
	    esac
	done

       parse_target_uri ${@:$OPTIND:1}

       if [ "$backup_local" = "yes" ]; then
           list=( "$backup_dir/"[0-9]*/ )

           (( ${#list[@]} > 0 )) || die "could not find any backups in $backup_dir/"

           # Print a header
           echo "List of local backups"
       else
           list=()
           while read -r -d '' d; do
	       list+=("$d")
           done < <(
	       ssh -n -- "$backup_ssh_target" \
	    "find $(qw "$backup_dir") -mindepth 1 -maxdepth 1 -name '[0-9]*' -type d -print0 | sort -z"
           )

           (( ${#list[@]} > 0 )) || die "could not find any backups in $backup_dir/ on $backup_host"

           # Print a header
           echo "List of backups on $backup_host"
       fi

       # Print the directory and stop time of each backup
       for dir in "${list[@]%/}"; do
           # Print the details of the backup dir
           if [ -n "$verbose" ]; then
	       echo "----------------------------------------------------------------------"
	       echo -e "Directory:\n  $dir"
           else
	       echo -ne "$dir\t"
           fi

           # Get the exact stop date from the backup label
           if [ "$backup_local" = "yes" ]; then
	       # Compute the size of full backup
	       backup_size=( $(du -sh -- "$dir") )
	       if [ -n "$verbose" ]; then
	           echo "  space used: $backup_size"
	       else
	           echo -ne "$backup_size\t"
	       fi

	       # Find the storage method of the backup, with compression suffix for tar
	       if [ -n "$verbose" ]; then
	           if [ -d "$dir/pgdata" ]; then
		       echo "  storage: rsync"
	           else
		       prefix=$dir/pgdata.tar.
		       tarfile=( "$prefix"* )
		       if (( ${#tarfile[@]} != 1 )); then
		           error "no rsync dir and ${#tarfile[@]} pgdata.tar files found"
		       else
		           suffix=${tarfile#$prefix}
		           [ -z "$suffix" ] && suffix="unknown"
		           echo "  storage: tar with $suffix compression"
		       fi
	           fi
	       fi

               # Print the minimum recovery target time with this backup
	       if [ -f "$dir/backup_label" ]; then
	           [ -n "$verbose" ] && echo "Minimum recovery target time:"
	           if stop_time=$(sed -n 's/STOP TIME: /  /p' -- "$dir/backup_label") && [ -n "$stop_time" ]; then
		       echo "$stop_time"
	           else
		       error "could not get \"stop time\" from $dir/backup_label"
	           fi
	       else
	           error "could not find the backup_label file"
	       fi

               if [ -n "$verbose" ]; then
	           # Display name, path and sizes of PGDATA and tablespaces
	           if [ -f "$dir/tblspc_list" ]; then
		       # Only show sizes of PGDATA if available
		       if [ -n "`awk -F'|' '{ print $4 }' "$dir/tblspc_list"`" ]; then
		           echo "PGDATA:"
		           if ! awk -F'|' '$2 == "" { print "  "$1" "$4 }' "$dir/tblspc_list"; then
			       error "could not display the list of tablespaces"
		           fi
		       fi
		       echo "Tablespaces:"
		       if ! awk -F'|' '$2 != "" { print "  \""$1"\" "$2" ("$3") "$4 }' "$dir/tblspc_list"; then
		           error "could not display the list of tablespaces"
		       fi
		       echo
	           else
		       error "could not find the list of tablespaces (tblspc_list)"
	           fi
	       fi
           else
	       # Backup size
	       backup_size=( $(ssh -n -- "$backup_ssh_target" "du -sh -- $(qw "$dir") 2>/dev/null" 2>/dev/null) )
	       if [ -n "$backup_size" ]; then
	           if [ -n "$verbose" ]; then
		       echo "  space used: $backup_size"
	           else
		       echo -ne "$backup_size\t"
	           fi
	       else
	           error "could not find size of $backup_host:$dir"
	       fi

               # Storage method with compression suffix for tar
	       if [ -n "$verbose" ]; then
	           if ssh -n -- "$backup_ssh_target" "test -d $(qw "$dir/pgdata")" 2>/dev/null; then
		       echo "  storage: rsync"
	           else
		       prefix=$dir/pgdata.tar.
		       tarfile=()
		       while read -r -d '' d; do
		           tarfile+=("$d")
		       done < <(
		           ssh -n -- "$backup_ssh_target" "find $(qw "$dir") -maxdepth 1 -name 'pgdata.tar.*' -type f -print0"
		       )

		       if (( ${#tarfile[@]} != 1 )); then
		           error "no rsync dir and ${#tarfile[@]} pgdata.tar files found in $backup_host:$dir"
		       else
		           suffix=${tarfile#$prefix}
		           [ -z "$suffix" ] && suffix="unknown"
		           echo "  storage: tar with $suffix compression"
		       fi
	           fi
	       fi

               # Minimum recovery target time
	       if ssh -n -- "$backup_ssh_target" "test -f $(qw "$dir/backup_label")" 2>/dev/null; then
	           [ -n "$verbose" ] && echo "Minimum recovery target time:"
	           if stop_time=$(ssh -n -- "$backup_ssh_target" "sed -n 's/STOP TIME: /  /p' -- $(qw "$dir/backup_label")") \
	                   && [ -n "$stop_time" ]; then
		       echo "$stop_time"
	           else
		       error "could not get \"stop time\" from $backup_host:$dir/backup_label"
	           fi
	       else
	           error "could find the backup_label file"
	       fi

               # Name, path and space used at backup time of PGDATA and tablespaces
	       if [ -n "$verbose" ]; then
	           if ssh -n -- "$backup_ssh_target" "test -f $(qw "$dir/tblspc_list")" 2>/dev/null; then
		       if [ -n "$(ssh -n -- "$backup_ssh_target" "awk -F'|' '{ print \$4 }' $(qw "$dir/tblspc_list")")" ]; then
		           echo "PGDATA:"
		           if ts=$(ssh -n -- "$backup_ssh_target" \
			               "awk -F'|' '\$2 == \"\" { print \"  \"\$1\" \"\$4 }' $(qw "$dir/tblspc_list")"); then
			       [ -n "$ts" ] && echo "$ts"
		           else
			       error "could not display the list of tablespaces"
		           fi
		       fi

		       echo "Tablespaces:"
		       if ts=$(ssh -n -- "$backup_ssh_target" \
			           "awk -F'|' '"'$2 != "" { print "  \""$1"\" "$2" ("$3") "$4 }'"' $(qw "$dir/tblspc_list")"); then
		           [ -n "$ts" ] && echo "$ts"
		       else
		           error "could not display the list of tablespaces"
		       fi
		       echo
	           else
		       error "could not find the list of tablespaces (tblspc_list)"
	           fi
	       fi
           fi

           if [ "$out_rc" != 0 ]; then
	       echo "!!! This backup may be imcomplete or corrupted !!!"
           fi
       done
       ;;

    backup)
	load_config

	# Parse args after action: they should take precedence over the configuration
	while getopts "D:s:c:e:tTP:h:p:U:d:?" arg 2>/dev/null; do
	    case $arg in
                D) PGDATA=$OPTARG;;
		s) STORAGE=$OPTARG;;
		c) BACKUP_COMPRESS_BIN=$OPTARG;;
		e) BACKUP_COMPRESS_SUFFIX=$OPTARG;;
                t) USE_ISO8601_TIMESTAMPS="yes";;
		T) LOG_TIMESTAMP="yes";;

	        P) PGPSQL=( "$OPTARG" );;
	        h) dbhost=$OPTARG;;
	        p) dbport=$OPTARG;;
	        U) dbuser=$OPTARG;;
	        d) dbname=$OPTARG;;

		'?') usage "backup";;
	    esac
	done

        # set the variables needed to access storage (handling of cli
        # vs config is handled by the function)
        parse_target_uri ${@:$OPTIND:1}

        # initialize the target path
        backup_root=$backup_dir
        backup_dir="$backup_root/current"

        # Only tar or rsync are allowed as storage method
        if [ "$STORAGE" != "tar" ] && [ "$STORAGE" != "rsync" ]; then
            die "storage method must be 'tar' or 'rsync'"
        fi

        # PGDATA may be used directly from the environment, so check if it is ok
        [ -n "$PGDATA" ] || die "PGDATA is not set"
        [ -d "$PGDATA" ] || die "PGDATA is not a directory"
        
        # Prepare the text will put in the backup_label
        label_text="pitrery_${version}_`date +%s`"

        # Prepare psql command line. Starting from 9.6 .psqlrc is sourced with
        # psql -c or -f, so we force -X
        psql_command=( "$PGPSQL" "-X" )
        [ -n "$dbhost" ] && psql_command+=( "-h" "$dbhost" )
        [ -n "$dbport" ] && psql_command+=( "-p" "$dbport" )
        [ -n "$dbuser" ] && psql_command+=( "-U" "$dbuser" )

        psql_condb=$dbname

        # Exports for both the pre and post backup hooks.
        export PITRERY_HOOK="pre_backup"
        export PITRERY_BACKUP_DIR=$backup_dir
        export PITRERY_PSQL="${psql_command[@]}"
        export PITRERY_DATABASE=$psql_condb
        export PITRERY_BACKUP_LOCAL=$local_backup
        export PITRERY_SSH_TARGET=$ssh_target

        # Get the version of the server
        if ! pg_version=$("${psql_command[@]}" -Atc "SELECT setting FROM pg_settings WHERE name = 'server_version_num';" \
				               -- "$psql_condb"); then
            die "could not get the version of the server"
        fi

        # Check if the server is in hot standby, it can happen from 9.0
        # otherwise we would have already exited on error.
        if (( 10#$pg_version >= 90000 )); then
            if ! standby=$("${psql_command[@]}" -Atc "SELECT pg_is_in_recovery();" -- "$psql_condb"); then
	        die "could not check if the server is in recovery"
            fi

            if [ "$standby" = "t" ]; then
                # Starting from 9.6 it is possible to backup from a standby
                # using an non-exclusive backup
                if (( $pg_version < 90600 )); then
                    die "unable to perform a base backup on a server in recovery mode. Aborting"
                fi

                # We use a coprocess for non-exclusive backups, the feature is
                # available in bash 4 and later.
                if (( ${BASH_VERSINFO[0]} < 4 )); then
                    die "bash version is too old to perform a non-exclusive backup from a standby server. Aborting"
                else
                    info "performing backup from hot standby server"
                fi
            fi
        fi

        # Prepare target directories
        info "preparing directories in ${target:+$target:}$backup_root/"

        if [ "$backup_local" = "yes" ]; then
            # Ensure the destination is clean from failed backups and that no
            # concurrent backup is running, the "current" temporary directory
            # acts as a lock.
            if [ -e "$backup_dir" ]; then
                die "$backup_dir already exists, another backup may be in progress"
            fi

            can_cleanup="yes"
            if ! mkdir -p -- "$backup_dir/tblspc"; then
	        die "could not create $backup_dir/tblspc"
            fi
        else
            if ssh -n -- "$ssh_target" "test -e $(qw "$backup_dir")" 2>/dev/null; then
	        die "$backup_dir already exists, another backup may be in progress"
            fi

            can_cleanup="yes"
            if ! ssh -n -- "$ssh_target" "mkdir -p -- $(qw "$backup_dir/tblspc")" 2>/dev/null; then
	        die "could not create $backup_dir/tblspc"
            fi
        fi

        # Execute the pre-backup command
        if [ -n "$PRE_BACKUP_COMMAND" ]; then
            info "running pre backup hook"
            if ! $PRE_BACKUP_COMMAND; then
	        die "pre_backup command exited with a non-zero code"
            fi
        fi

        # Get the list of tablespaces. It comes from PostgreSQL to be sure to
        # process only defined tablespaces.
        info "listing tablespaces"
        if ! tblspc_list=$(mktemp -t backup_pitr.XXXXXXXXXX); then
            die_and_hook "could not create temporary file"
        fi

        # Starting from 9.2, the location of tablespaces is no longer stored
        # in pg_tablespace. This allows to change locations of tablespaces by
        # modifying the symbolic links in pg_tblspc. As a result, the query to
        # get list of tablespaces is different.

        # Ask PostgreSQL the list of tablespaces
        if (( $pg_version >= 90200 )); then
            "${psql_command[@]}" -Atc "SELECT spcname, pg_tablespace_location(oid), oid, pg_size_pretty(pg_tablespace_size(oid)) FROM pg_tablespace;" -- "$psql_condb" > "$tblspc_list"
            rc=$?
        else
            "${psql_command[@]}" -Atc "SELECT spcname, spclocation, oid, pg_size_pretty(pg_tablespace_size(oid)) FROM pg_tablespace;" -- "$psql_condb" > "$tblspc_list"
            rc=$?
        fi

        if [ $rc != 0 ]; then
            die_and_hook "could not get the list of tablespaces from PostgreSQL"
        fi

        # Start the backup
        info "starting the backup process"

        # Starting from 9.6, PostgreSQL support concurrent base backups, those
        # are names non-exclusive backups. The older behaviour of exclusive
        # backups may be deprecated.
        if (( $pg_version >= 90600 )) && (( ${BASH_VERSINFO[0]} >= 4 )); then
            info "performing a non-exclusive backup"
            # When taking a base backup in non-exclusive mode, the session
            # that issues the call to pg_start_backup() must stay connected
            # during the whole operation. We start psql inside a coprocess and
            # interact with it. Since the coprocess do not offer a pipe to
            # capture stderr, we redirect it to a temporary file. Testing if
            # this file is empty let us know that no error occured.
            if ! psql_stderr=$(mktemp -t backup_pitr_psql_stderr.XXXXXXXXXX); then
                die_and_hook "could not create temporary file"
            fi

            coproc ${psql_command[@]} -At $psql_condb 2>$psql_stderr

            get_psql_output() {
                # First wait for output to be ready on the fd. When there is
                # an error, no output go to the fd
                while ! read -t 0 -u ${COPROC[0]}; do
                    if ! grep -E "^(ERROR|FATAL)" $psql_stderr >/dev/null 2>&1; then
                        sleep 1
                    else
                        return 1
                    fi
                done

                # When the fd has some data, read everything and change
                # newlines to pipe characters, to pass through expansion of
                # newline to space, when stored as a string.
                while read -t 1 -u ${COPROC[0]} line; do
                    [ -n "$line" ] && echo -n "$line|"
                done
                return 0
            }

            check_psql_stderr() {
                if grep -E "^(ERROR|FATAL)" $psql_stderr >/dev/null 2>&1; then
                    return 1
                else
                    return 0
                fi
            }

            # Check if the connection works by getting the pid of the backend
            echo 'select pg_backend_pid();' >&${COPROC[1]} # 2>/dev/null
            if [ $? != 0 ]; then
                check_psql_stderr || cat $psql_stderr
                die_and_hook "could not check connection to PostgreSQL"
            fi
            psql_pid=$(get_psql_output)

            # Start the base backup
            echo "select pg_start_backup('${label_text}', true, false);"  >&${COPROC[1]}
            if [ $? != 0 ]; then
                check_psql_stderr || cat $psql_stderr
                die_and_hook "could not start backup process (command sending)"
            fi

            start_backup_lsn=$(get_psql_output)
            if [ -z "$start_backup_lsn" ]; then
                check_psql_stderr || cat $psql_stderr
                die_and_hook "could not start backup process (empty output)"
            fi
        else
            # Force a checkpoint for version >= 8.4. We add some parsing of the
            # result of pg_xlogfile_name_offset on the LSN returned by
            # pg_start_backup, so that we have the name of the backup_label that
            # will be archived after pg_stop_backup completes
            if (( $pg_version >= 80400 )); then
                start_backup_label_file=`${psql_command[@]} -Atc "select i.file_name ||'.'|| lpad(upper(to_hex(i.file_offset)), 8, '0') || '.backup' from pg_xlogfile_name_offset(pg_start_backup('${label_text}', true)) as i;" $psql_condb`
                rc=$?
            else
                start_backup_label_file=`${psql_command[@]} -Atc "select i.file_name ||'.'|| lpad(upper(to_hex(i.file_offset)), 8, '0') || '.backup' from pg_xlogfile_name_offset(pg_start_backup('${label_text}')) as i;" $psql_condb`
                rc=$?
            fi

            if [ $rc != 0 ]; then
                die_and_hook "could not start backup process"
            fi
        fi

        # Add a signal handler to avoid leaving the cluster in backup mode when exiting on error
        trap stop_backup INT TERM KILL EXIT

        # When using rsync storage, search for the previous backup to prepare
        # the target directories. We try to optimize the space usage by
        # hardlinking the previous backup, so that files that have not changed
        # between backups are not duplicated from a filesystem point of view
        if [ "$STORAGE" = "rsync" ]; then
            if [ "$backup_local" = "yes" ]; then
	        list=( "$backup_root/"[0-9]*/ )
	        if (( ${#list[@]} > 0 )); then
	            _dir=${list[*]: -1}

	            # Since the previous backup can be in tar storage, check
	            # that a pgdata subdirectory exists
	            [ -d "${_dir%/}/pgdata" ] && prev_backup=${_dir%/}
	        fi
            else
	        _dir=$(ssh -n -- "$ssh_target" "f=\$(find $(qw "$backup_root") -mindepth 1 -maxdepth 1 -name '[0-9]*' -type d -print0 | sort -rz | cut -d '' -f1) && printf '%s' \"\$f\"")
	        if ssh -n -- "$ssh_target" "test -d $(qw "$_dir/pgdata")" 2>/dev/null; then
	            prev_backup="$_dir"
	        fi
            fi
        fi

        # Enable the extended pattern matching operators.
        # We use them here for replacing whitespace in the tablespace tarball names.
        shopt -s extglob

        # Copy the files
        case $STORAGE in
            "tar")
                # Tar $PGDATA
	        info "backing up PGDATA with tar"
	        was=`pwd`
	        if ! cd -- "$PGDATA"; then
	            die_and_hook "could not change current directory to $PGDATA"
	        fi

	        info "archiving $PGDATA"
	        if [ "$backup_local" = "yes" ]; then
	            tar -cpf - --ignore-failed-read --exclude='pg_xlog' --exclude='pg_replslot/*' --exclude='postmaster.*' --exclude='pgsql_tmp' --exclude='restored_config_files' --exclude='backup_label.old' --exclude='*.sql' -- * 2>/dev/null | $BACKUP_COMPRESS_BIN > "$backup_dir/pgdata.tar.$BACKUP_COMPRESS_SUFFIX"
	            rc=(${PIPESTATUS[*]})
	            tar_rc=${rc[0]}
	            compress_rc=${rc[1]}
	            if [ "$tar_rc" = 2 ] || [ "$compress_rc" != 0 ]; then
		        die_and_hook "could not tar PGDATA"
	            fi
	        else
	            tar -cpf - --ignore-failed-read --exclude='pg_xlog' --exclude='pg_replslot/*' --exclude='postmaster.*' --exclude='pgsql_tmp' --exclude='restored_config_files' --exclude='backup_label.old' --exclude='*.sql' -- * 2>/dev/null | $BACKUP_COMPRESS_BIN | ssh -- "$ssh_target" "cat > $(qw "$backup_dir/pgdata.tar.$BACKUP_COMPRESS_SUFFIX")" 2>/dev/null
	            rc=(${PIPESTATUS[*]})
	            tar_rc=${rc[0]}
	            compress_rc=${rc[1]}
	            ssh_rc=${rc[2]}
	            if [ "$tar_rc" = 2 ] || [ "$compress_rc" != 0 ] || [ "$ssh_rc" != 0 ]; then
		        die_and_hook "could not tar PGDATA"
	            fi
	        fi
	        cd -- "$was"

	        # Tar the tablespaces
	        while read line ; do
	            name=$(cut -d '|' -f 1 <<< "$line")
	            _name=${name//+([[:space:]])/_}	# No space version, we want paths without spaces
	            location=$(cut -d '|' -f 2 <<< "$line")

	            # Skip empty locations used for pg_default and pg_global, which are in PGDATA
	            [ -z "$location" ] && continue

	            info "backing up tablespace \"$name\" with tar"

                    # Change directory to the parent directory or the tablespace to be
                    # able to tar only the base directory
	            was=`pwd`
	            if ! cd -- "$location"; then
		        die_and_hook "could not change current directory to $location"
	            fi

	            # Tar the directory, directly to the remote location if needed.  The name
                    # of the tar file is the tablespace name defined in the cluster, which is
                    # unique.
	            info "archiving $location"
	            if [ "$backup_local" = "yes" ]; then
		        tar -cpf - --ignore-failed-read --exclude='pgsql_tmp' -- * 2>/dev/null | $BACKUP_COMPRESS_BIN > "$backup_dir/tblspc/${_name}.tar.$BACKUP_COMPRESS_SUFFIX"
		        rc=(${PIPESTATUS[*]})
		        tar_rc=${rc[0]}
		        compress_rc=${rc[1]}
		        if [ "$tar_rc" = 2 ] || [ "$compress_rc" != 0 ]; then
		            die_and_hook "could not tar tablespace \"$name\""
		        fi
	            else
		        tar -cpf - --ignore-failed-read --exclude='pgsql_tmp' -- * 2>/dev/null | $BACKUP_COMPRESS_BIN | ssh -- "$ssh_target" "cat > $(qw "$backup_dir/tblspc/${_name}.tar.$BACKUP_COMPRESS_SUFFIX")" 2>/dev/null
		        rc=(${PIPESTATUS[*]})
		        tar_rc=${rc[0]}
		        compress_rc=${rc[1]}
		        ssh_rc=${rc[2]}
		        if [ "$tar_rc" = 2 ] || [ "$compress_rc" != 0 ] || [ "$ssh_rc" != 0 ]; then
		            die_and_hook "could not tar tablespace \"$name\""
		        fi
	            fi

	            cd -- "$was"

	        done < "$tblspc_list"
	        ;;



            "rsync")
	        info "backing up PGDATA with rsync"
	        rsync_link=()
	        if [ -n "$prev_backup" ]; then
	            # Link previous backup of pgdata
	            info "backup with hardlinks from $prev_backup"
	            if [ "$backup_local" = "yes" ]; then
		        rsync_link=( '--link-dest' "$prev_backup/pgdata" )
	            else
		        rsync_link=( '--link-dest' "$(qw "$prev_backup/pgdata")" )
	            fi
	        fi

	        info "transferring data from $PGDATA"
	        if [ "$backup_local" = "yes" ]; then
	            rsync -aq --delete-excluded --exclude 'pgsql_tmp' --exclude 'pg_xlog' --exclude 'pg_replslot/*' --exclude 'postmaster.*' --exclude 'restored_config_files' --exclude 'backup_label.old' --exclude '*.sql' "${rsync_link[@]}" -- "$PGDATA/" "$backup_dir/pgdata/"
	            rc=$?
	            if [ $rc != 0 ] && [ $rc != 24 ]; then
		        die_and_hook "rsync of PGDATA failed with exit code $rc"
	            fi
	        else
	            rsync -e "ssh -o Compression=no" -zaq --delete-excluded --exclude 'pgsql_tmp' --exclude 'pg_xlog' --exclude 'pg_replslot/*' --exclude 'postmaster.*' --exclude 'restored_config_files' --exclude 'backup_label.old' --exclude '*.sql' "${rsync_link[@]}" -- "$PGDATA/" "$ssh_target:$(qw "$backup_dir/pgdata/")"
	            rc=$?
	            if [ $rc != 0 ] && [ $rc != 24 ]; then
		        die_and_hook "rsync of PGDATA failed with exit code $rc"
	            fi
	        fi


	        # Tablespaces. We do the same as pgdata: hardlink the previous
	        # backup directory if possible, then rsync.
	        while read line; do
	            name=$(cut -d '|' -f 1 <<< "$line")
	            _name=${name//+([[:space:]])/_}	# No space version, we want paths without spaces
	            location=$(cut -d '|' -f 2 <<< "$line")

	            # Skip empty locations used for pg_default and pg_global, which are in PGDATA
	            [ -z "$location" ] && continue

	            info "backing up tablespace \"$name\" with rsync"

	            rsync_link=()
	            if [ -n "$prev_backup" ]; then
	    	        # Link previous backup of the tablespace
		        if [ "$backup_local" = "yes" ]; then
		            [ -d "$prev_backup/tblspc/$_name" ] && rsync_link=( '--link-dest' "$prev_backup/tblspc/$_name" )
		        else
                            if ssh -n -- "$ssh_target" "test -d $(qw "$prev_backup/tblspc/$_name")" 2>/dev/null; then
		                rsync_link=( '--link-dest' "$(qw "$prev_backup/tblspc/$_name")" )
                            fi
		        fi
	            fi

	            # rsync
	            info "transferring data from $location"
	            if [ "$backup_local" = "yes" ]; then
		        rsync -aq --delete-excluded --exclude 'pgsql_tmp' "${rsync_link[@]}" -- "$location/" "$backup_dir/tblspc/$_name/"
		        rc=$?
		        if [ $rc != 0 ] && [ $rc != 24 ]; then
	    	            die_and_hook "rsync of tablespace \"$name\" failed with exit code $rc"
	    	        fi
	            else
		        rsync -e "ssh -o Compression=no" -zaq --delete-excluded --exclude 'pgsql_tmp' "${rsync_link[@]}" -- "$location/" "$ssh_target:$(qw "$backup_dir/tblspc/$_name/")"
		        rc=$?
		        if [ $rc != 0 ] && [ $rc != 24 ]; then
	    	            die_and_hook "rsync of tablespace \"$name\" failed with exit code $rc"
	    	        fi
	            fi

	        done < "$tblspc_list"
	        ;;



            *)
	        die_and_hook "Unknown STORAGE method '$STORAGE'"
	        ;;
        esac

        # Backup replication slots informations to a separate file. If we take
        # their status files and restore them, they would be restored as stale
        # slots. Instead we'll give the commands to recreate them after the
        # restore.
        if (( $pg_version >= 90400 )); then
            if ! replslot_list=$(mktemp -t backup_pitr.XXXXXXXXXX); then
	        die_and_hook "could not create temporary file"
            fi

            "${psql_command[@]}" -Atc \
	                         "SELECT slot_name,plugin,slot_type,database FROM pg_replication_slots;" \
	                         -- "$psql_condb" 2>/dev/null > "$replslot_list" ||
	        die_and_hook "could not get the list of replication slots from PostgreSQL"
        fi

        # Starting from 9.6 and when the backup is from a standby server,
        # PostgreSQL relies on the pg_control file being backed up last to
        # find the backend end location in the WAL. In this case, backup the
        # pg_control file just before ending the backup.
        if (( $pg_version >= 90600 )) && [ "$standby" = "t" ]; then
            info "backup it taken from a standby server, copying the pg_control file"
            if [ "$backup_local" = "yes" ]; then
                if ! cp -- "$PGDATA/global/pg_control" "$backup_dir/"; then
                    die_and_hook "could not copy the pg_control file to $backup_dir"
                fi
            else
                if ! scp -- "$PGDATA/global/pg_control" "$ssh_target:$(qw "$backup_dir/")" > /dev/null; then
	            die_and_hook "could not copy the pg_control file to $target:$backup_dir"
                fi
            fi
        fi

        # Stop backup
        stop_backup

        if (( $pg_version >= 90600 )) && (( ${BASH_VERSINFO[0]} >= 4 )); then
            # In non-exclusive mode, we have to write the backup_label files
            # ourselves. When using the tar storage, we cannot add the file to
            # PGDATA inside the tarball, so we just create files locally, and
            # copy them to the backup directory later. It is the job of the
            # restore to put them back in the correct location ($PGDATA) when
            # restoring.

            # Create the backup_label as a temporary file and put its contents
            if ! backup_label_file=$(mktemp -t backup_pitr_backup_label.XXXXXXXXXX); then
                die_and_hook "could not create temporary file"
            fi

            # Use an alternative name so we do not have to check the version
            # to remove this temp file
            backup_file=$backup_label_file
            
            echo -n $label_contents | tr '|' '\n' > $backup_file
            if [ $? != 0 ]; then
                die_and_hook "could not write temporary backup_label file"
            fi

            # Same goes for the tablespace mapfile (tablespace_map)
            if [ -n "$spcmap_contents" ]; then
                if ! tablespace_map_file=$(mktemp -t backup_pitr_tablespace_map.XXXXXXXXXX); then
                    die_and_hook "could not create temporary file"
                fi

                echo -n $spcmap_contents | tr '|' '\n' > $tablespace_map_file
                if [ $? != 0 ]; then
                    die_and_hook "could not write temporary tablespace_map file"
                fi
            fi
        else
            # The complete backup_label is going to be archived. We put it in the
            # backup, just in case and also use the stop time from the file to
            # name the backup directory and have the minimum datetime required to
            # select this backup on restore.
            backup_file="$PGDATA/pg_xlog/$start_backup_label_file"

            # Get the stop date of the backup. 
            stop_time=$(sed -n 's/STOP TIME: //p' -- "$backup_file")
        fi

        # Convert the stop time to UTC, this make it easier when searching for
        # a proper backup when restoring
        if [ -n "$stop_time" ]; then
            timestamp=$(${psql_command[@]} -Atc "SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '${stop_time}');" $psql_condb) ||
                warn "could not get the stop time timestamp from PostgreSQL"
        else
            die_and_hook "Failed to get STOP TIME from '$backup_file'"
        fi

        # Ask PostgreSQL where are its configuration file. When they are
        # outside PGDATA, copy them in the backup
        _pgdata=`readlink -f -- "$PGDATA"`

        while read -r -d '' f; do
            file=`readlink -f -- "$f"`
            if [[ ! $file =~ ^"$_pgdata" ]]; then
	        # the file in not inside PGDATA, copy it
	        destdir=$backup_dir/conf
	        dest=$destdir/$(basename -- "$file")
	        info "saving $f"

	        if [ "$local_backup" = "yes" ]; then
	            mkdir -p -- "$destdir"
	            if ! cp -- "$file" "$dest"; then
		        die_and_hook "could not copy $f to backup directory"
	            fi
	        else
	            ssh -n -- "$ssh_target" "mkdir -p -- $(qw "$destdir")" 2>/dev/null
	            if ! scp -- "$file" "$ssh_target:$(qw "$dest")" >/dev/null; then
		        die_and_hook "could not copy $f to backup directory on $target"
	            fi
	        fi
            fi
        done < <(
            # The values of the settings is dependant of the user, it means
            # those path can include characters such as newline, which can
            # conflict with the record separator. We could use psql -0 but it
            # is not available before 9.2, this is why we loop and build nul
            # separated output this way.
            for f in 'config_file' 'hba_file' 'ident_file'; do
	        "${psql_command[@]}" -Atc \
                                     "SELECT setting FROM pg_settings WHERE name = '$f';" \
	                             -- "$psql_condb" \
 	            || warn "could not get the list of configuration files from PostgreSQL"
	        printf "\0"
            done
        )

        # Compute the name of the backup directory from the stop time, use
        # date to format the stop time as ISO 8601 if required. When we can have
        if [[ "$USE_ISO8601_TIMESTAMPS" == "yes" ]]; then
            backup_name=$(date -d "$stop_time" +"%FT%T%z") ||
                error_and_hook "could not format stop time to a directory name"
        else
            backup_name=$(echo $stop_time | awk '{ gsub(/[:-]/, "."); print $1"_"$2 }')
        fi
        new_backup_dir=$backup_root/$label_prefix/$backup_name

        # Finish the backup by copying needed files and rename the backup
        # directory to a useful name
        if [ "$backup_local" = "yes" ]; then
            [ ! -e "$new_backup_dir" ] ||
	        die_and_hook "backup directory '$new_backup_dir' already exists"

            # Rename the backup directory using the stop time
            if ! mv -- "$backup_dir" "$new_backup_dir"; then
	        die_and_hook "could not rename the backup directory"
            fi
            backup_dir=$new_backup_dir
            
            # Copy the backup history file
            info "copying the backup history file"
            if ! cp -- "$backup_file" "$backup_dir/backup_label"; then
	        die_and_hook "could not copy backup history file to $backup_dir"
            fi

            # Copy the tablespace mapfile from pg_stop_backup() in
            # non-exclusive mode
            if (( $pg_version >= 90600 )) && (( ${BASH_VERSINFO[0]} >= 4 )); then
                if [ -n "$tablespace_map_file" ]; then
                    info "copying the tablespace_map file"
                    if ! cp -- "$tablespace_map_file" "$backup_dir/tablespace_map"; then
                        die_and_hook "could not copy tablespace_map to $backup_dir"
                    fi
                fi
            fi

            # Save the end of backup timestamp to a file
            if [ -n "$timestamp" ]; then
	        echo "$timestamp" > "$backup_dir/backup_timestamp" || warn "could not save timestamp"
            fi

            # Add the name and location of the tablespace to an helper file for
            # the restoration script
            info "copying the tablespaces list"
            if ! cp -- "$tblspc_list" "$backup_dir/tblspc_list"; then
	        die_and_hook "could not copy the tablespace list to $backup_dir"
            fi

            # Save the list of defined replication slots
            if [ -f "$replslot_list" ] && (( $(cat -- "$replslot_list" | wc -l) > 0 )); then
	        info "copying the replication slots list"
	        cp -- "$replslot_list" "$backup_dir/replslot_list" ||
	            die_and_hook "could not copy the replication slots list to $backup_dir"
            fi

            # Copy the PG_VERSION file
            info "copying PG_VERSION"
            if ! cp -- "$PGDATA/PG_VERSION" "$backup_dir"; then
                die_and_hook "could not copy PG_VERSION to $backup_dir"
            fi
        else
            if ssh -n -- "$backup_ssh_target" "test -e $(qw "$new_backup_dir")" 2>/dev/null; then
	        die_and_hook "backup directory '$backup_ssh_target:$new_backup_dir' already exists"
            fi

            # Rename the backup directory using the stop time
            if ! ssh -n -- "$backup_ssh_target" "mv -- $(qw "$backup_dir" "$new_backup_dir")" 2>/dev/null; then
	        die_and_hook "could not rename the backup directory"
            fi
            backup_dir=$new_backup_dir
            
            # Save the end of backup timestamp to a file
            if [ -n "$timestamp" ]; then
	        ssh -n -- "$backup_ssh_target" "echo '$timestamp' > $(qw "$backup_dir/backup_timestamp")" 2>/dev/null ||
	            warn "could not save timestamp"
            fi

            # Copy the backup history file
            info "copying the backup history file"
            if ! scp -- "$backup_file" "$backup_ssh_target:$(qw "$backup_dir/backup_label")" > /dev/null; then
	        die_and_hook "could not copy backup history file to $backup_ssh_target:$backup_dir"
            fi

            # Copy the tablespace mapfile from pg_stop_backup() in
            # non-exclusive mode
            if (( $pg_version >= 90600 )) && (( ${BASH_VERSINFO[0]} >= 4 )); then
                if [ -n "$tablespace_map_file" ]; then
                    info "copying the tablespace_map file"
                    if ! scp -- $tablespace_map_file "$backup_ssh_target:$(qw "$backup_dir/tablespace_map")" > /dev/null; then
                        die_and_hook "could not copy tablespace_map to $backup_ssh_target:$backup_dir"
                    fi
                fi
            fi

            # Add the name and location of the tablespace to an helper file for
            # the restoration script
            info "copying the tablespaces list"
            if ! scp -- "$tblspc_list" "$backup_ssh_target:$(qw "$backup_dir/tblspc_list")" >/dev/null; then
	        die_and_hook "could not copy the tablespace list to $backup_ssh_target:$backup_dir"
            fi

            # Save the list of defined replication slots
            if [ -f "$replslot_list" ] && (( $(cat -- "$replslot_list" | wc -l) > 0 )); then
	        info "copying the replication slots list"
	        scp -- "$replslot_list" "$backup_ssh_target:$(qw "$backup_dir/replslot_list")" >/dev/null ||
	            die_and_hook "could not copy the replication slots list to $backup_ssh_target:$backup_dir"
            fi

            # Copy the PG_VERSION file
            info "copying PG_VERSION"
            if ! scp -- "$PGDATA/PG_VERSION" "$backup_ssh_target:$(qw "$backup_dir")" >/dev/null; then
	        die_and_hook "could not copy PG_VERSION to $backup_ssh_target:$backup_dir"
            fi
        fi

        # Give the name of the backup
        info "backup directory is ${backup_ssh_target:+$backup_ssh_target:}$backup_dir"

        # Execute the post-backup command. It does not return on failure.
        PITRERY_EXIT_CODE=0
        post_backup_hook

        # Cleanup
        rm -f -- "$tblspc_list"
        [ -n "$replslot_list" ] && rm -f -- "$replslot_list"
        [ -n "$psql_stderr" ] && rm -f -- "$psql_stderr"
        [ -n "$backup_label_file" ] && rm -f -- "$backup_label_file"
        [ -n "$tablespace_map_file"  ] && rm -f -- "$tablespace_map_file"

        info "done"

        
	;;

    restore)
	load_config
	select_cmd "restore_pitr"

	# Parse args after action: they should take precedence over the configuration
	while getopts "Lu:b:l:D:x:d:O:t:nRc:e:r:C:T?" arg 2>/dev/null; do
	    case $arg in
		L) BACKUP_IS_LOCAL="yes";;
		u) BACKUP_USER=$OPTARG;;
		b) BACKUP_DIR=$OPTARG;;
		l) BACKUP_LABEL=$OPTARG;;
		D) PGDATA=$OPTARG;;
		x) PGXLOG=$OPTARG;;
		d) TARGET_DATE=$OPTARG;;
		O) PGOWNER=$OPTARG;;
		t) TBLSPC_RELOC+=( "-t" "$OPTARG" );;
		n) DRY_RUN="yes";;
		R) OVERWRITE="yes";;
		c) BACKUP_UNCOMPRESS_BIN=$OPTARG;;
		e) BACKUP_COMPRESS_SUFFIX=$OPTARG;;
		r) RESTORE_COMMAND=$OPTARG;;
		C) RESTORE_XLOG_CONFIG=$OPTARG;;
		T) LOG_TIMESTAMP="yes";;

		"?") "$cmd" '-?'; exit $?;;
	    esac
	done

	# Add relevant options coming from the configuration
	[ "$BACKUP_IS_LOCAL" = "yes" ]	    && opts+=( "-L" )
	[ -n "$BACKUP_USER" ]		    && opts+=( "-u" "$BACKUP_USER" )
	[ -n "$BACKUP_DIR" ]		    && opts+=( "-b" "$BACKUP_DIR" )
	[ -n "$BACKUP_LABEL" ]		    && opts+=( "-l" "$BACKUP_LABEL" )
	[ -n "$PGDATA" ]		    && opts+=( "-D" "$PGDATA" )
	[ -n "$PGXLOG" ]		    && opts+=( "-x" "$PGXLOG" )
	[ -n "$TARGET_DATE" ]		    && opts+=( "-d" "$TARGET_DATE" )
	[ -n "$PGOWNER" ]		    && opts+=( "-O" "$PGOWNER" )
	(( ${#TBLSPC_RELOC[@]} > 0 ))	    && opts+=( "${TBLSPC_RELOC[@]}" )
	[ "$DRY_RUN" = "yes" ]		    && opts+=( "-n" )
	[ -n "$OVERWRITE" ]		    && opts+=( "-R" )
	[ -n "$BACKUP_UNCOMPRESS_BIN" ]	    && opts+=( "-c" "$BACKUP_UNCOMPRESS_BIN" )
	[ -n "$BACKUP_COMPRESS_SUFFIX" ]    && opts+=( "-e" "$BACKUP_COMPRESS_SUFFIX" )
	[ -n "$RESTORE_COMMAND" ]	    && opts+=( "-r" "$RESTORE_COMMAND" )
	[ "$LOG_TIMESTAMP" = "yes" ]	    && opts+=( "-T" )

	# Pass along the configuration file
	if [ -n "$RESTORE_XLOG_CONFIG" ]; then
	    opts+=( "-C" "$RESTORE_XLOG_CONFIG" )
	elif [ "$config" != "@SYSCONFDIR@/pitr.conf" ]; then
	    opts+=( "-C" "$config" )
	fi

	run_cmd "${@:$OPTIND:1}"
	;;

    purge)
	load_config
	select_cmd "purge_pitr"

	# Parse args after action: they should take precedence over the configuration
	while getopts "Ll:b:u:n:U:X:m:d:NT?" arg 2>/dev/null; do
	    case $arg in
		L) BACKUP_IS_LOCAL="yes";;
		l) BACKUP_LABEL=$OPTARG;;
		b) BACKUP_DIR=$OPTARG;;
		u) BACKUP_USER=$OPTARG;;
		n) ARCHIVE_HOST=$OPTARG;;
		U) ARCHIVE_USER=$OPTARG;;
		X) ARCHIVE_DIR=$OPTARG;;
		m) PURGE_KEEP_COUNT=$OPTARG;;
		d) PURGE_OLDER_THAN=$OPTARG;;
		N) DRY_RUN="yes";;
		T) LOG_TIMESTAMP="yes";;

		"?") "$cmd" '-?'; exit $?;;
	    esac
	done

	# Add relevant options coming from the configuration
	[ "$BACKUP_IS_LOCAL" = "yes" ]	&& opts+=( "-L" )
	[ -n "$BACKUP_DIR" ]		&& opts+=( "-b" "$BACKUP_DIR" )
	[ -n "$BACKUP_LABEL" ]		&& opts+=( "-l" "$BACKUP_LABEL" )
	[ -n "$BACKUP_USER" ]		&& opts+=( "-u" "$BACKUP_USER" )
	[ -n "$ARCHIVE_HOST" ]		&& opts+=( "-n" "$ARCHIVE_HOST" )
	[ -n "$ARCHIVE_USER" ]		&& opts+=( "-U" "$ARCHIVE_USER" )
	[ -n "$ARCHIVE_DIR" ]		&& opts+=( "-X" "$ARCHIVE_DIR" )
	[ -n "$PURGE_KEEP_COUNT" ]	&& opts+=( "-m" "$PURGE_KEEP_COUNT" )
	[ -n "$PURGE_OLDER_THAN" ]	&& opts+=( "-d" "$PURGE_OLDER_THAN" )
	[ "$DRY_RUN" = "yes" ]		&& opts+=( "-N" )
	[ "$LOG_TIMESTAMP" = "yes" ]	&& opts+=( "-T" )

	run_cmd "${@:$OPTIND:1}"
	;;

    check)
	load_config
	select_cmd "check_pitr"

	while getopts "C:?" opt; do
	    case $opt in
		C) PITR_CONFIG=$OPTARG;;
		"?") "$cmd" '-?'; exit $?;;
	    esac
	done

	if [ -n "$PITR_CONFIG" ]; then
	    opts+=( "-C" "$PITR_CONFIG" )
	else
	    opts+=( "-C" "$config" )
	fi

        # Run the command
	$dry_run "$cmd" "${opts[@]}"
	exit $?
	;;

    configure)
	# Here we do not load any configuration so that it does not
	# change the output in the back of the user. This is important
	# for PostgreSQL related environment variables that we do not
	# want to overwrite. This is why the following loop getopts on
	# get just pass in the command line.
	select_cmd "configure_pitr"

	while getopts "o:fCl:s:m:g:D:a:P:h:p:U:d:?" opt; do
	    case $opt in
		o) opts+=( "-o" "$OPTARG" );;
		f) opts+=( "-f" );;
		C) opts+=( "-C" );;
		l) opts+=( "-l" "$OPTARG" );;
		s) opts+=( "-s" "$OPTARG" );;
		m) opts+=( "-m" "$OPTARG" );;
		g) opts+=( "-g" "$OPTARG" );;
		D) opts+=( "-D" "$OPTARG" );;
		a) opts+=( "-a" "$OPTARG" );;

		P) opts+=( "-P" "$OPTARG" );;
		h) opts+=( "-h" "$OPTARG" );;
		p) opts+=( "-p" "$OPTARG" );;
		U) opts+=( "-U" "$OPTARG" );;
		d) opts+=( "-d" "$OPTARG" );;

		"?") "$cmd" '-?'; exit $?;;
	    esac
	done

	[ -n "${@:$OPTIND:1}" ] && opts+=( "${@:$OPTIND:1}" )
	$dry_run "$cmd" "${opts[@]}"
	exit $?
	;;

    *)
	error "unknown action"
	;;
esac

exit $out_rc
